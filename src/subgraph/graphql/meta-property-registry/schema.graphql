# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type AddCategory {
    allowSplit: Boolean!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Bytes!
    id: Bytes!
    manager: Bytes!
    properties: [Bytes!]!
    transactionHash: Bytes!
}

type AddCategoryProperty {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Bytes!
    id: Bytes!
    properties: [Bytes!]!
    transactionHash: Bytes!
}

type AdminChanged {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newAdmin: Bytes!
    previousAdmin: Bytes!
    transactionHash: Bytes!
}

type Approval {
    approved: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    manager: PropertyManager!
    owner: Bytes!
    tokenId: BigInt!
    transactionHash: Bytes!
}

type ApprovalForAll {
    approved: Boolean!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    manager: PropertyManager!
    operator: Bytes!
    owner: Bytes!
    transactionHash: Bytes!
}

type BeaconUpgraded {
    beacon: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
}

type Category {
    allowSplit: Boolean!
    category: Bytes!
    id: Bytes!
    manager: PropertyManager!
    properties(first: Int = 100, orderBy: Property_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Property_filter): [Property!]!
}

type ERC721OpenMintPMExampleAdminChanged {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newAdmin: Bytes!
    previousAdmin: Bytes!
    transactionHash: Bytes!
}

type ERC721OpenMintPMExampleBeaconUpgraded {
    beacon: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
}

type ERC721OpenMintPMExampleInitialized {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
    version: Int!
}

type ERC721OpenMintPMExampleRoleAdminChanged {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newAdminRole: Bytes!
    previousAdminRole: Bytes!
    role: Bytes!
    transactionHash: Bytes!
}

type ERC721OpenMintPMExampleRoleGranted {
    account: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    role: Bytes!
    sender: Bytes!
    transactionHash: Bytes!
}

type ERC721OpenMintPMExampleRoleRevoked {
    account: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    role: Bytes!
    sender: Bytes!
    transactionHash: Bytes!
}

type ERC721OpenMintPMExampleUpgraded {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    implementation: Bytes!
    transactionHash: Bytes!
}

type GrantCategoryManager {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Bytes!
    id: Bytes!
    manager: Bytes!
    transactionHash: Bytes!
}

type GrantMinter {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    manager: Bytes!
    transactionHash: Bytes!
}

type Initialized {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    transactionHash: Bytes!
    version: Int!
}

type NFT {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    manager: PropertyManager!
    owner: Bytes!
    tokenId: BigInt!
    transactionHash: Bytes!
}

type Property {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Category!
    id: Bytes!
    transactionHash: Bytes!
    value: Bytes!
}

type PropertyManager {
    categories(first: Int = 100, orderBy: Category_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Category_filter): [Category!]!
    id: Bytes!
    manager: Bytes!
    minter: Boolean!
    name: String!
    sender: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    addCategories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AddCategory_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AddCategory_filter
    ): [AddCategory!]!
    addCategory(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddCategory
    addCategoryProperties(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AddCategoryProperty_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AddCategoryProperty_filter
    ): [AddCategoryProperty!]!
    addCategoryProperty(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddCategoryProperty
    adminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AdminChanged
    adminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AdminChanged_filter
    ): [AdminChanged!]!
    approval(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Approval
    approvalForAll(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ApprovalForAll
    approvalForAlls(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ApprovalForAll_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ApprovalForAll_filter
    ): [ApprovalForAll!]!
    approvals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Approval_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Approval_filter
    ): [Approval!]!
    beaconUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BeaconUpgraded
    beaconUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BeaconUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BeaconUpgraded_filter
    ): [BeaconUpgraded!]!
    categories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Category_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Category_filter
    ): [Category!]!
    category(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Category
    erc721OpenMintPMExampleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleAdminChanged
    erc721OpenMintPMExampleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleAdminChanged_filter
    ): [ERC721OpenMintPMExampleAdminChanged!]!
    erc721OpenMintPMExampleBeaconUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleBeaconUpgraded
    erc721OpenMintPMExampleBeaconUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleBeaconUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleBeaconUpgraded_filter
    ): [ERC721OpenMintPMExampleBeaconUpgraded!]!
    erc721OpenMintPMExampleInitialized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleInitialized
    erc721OpenMintPMExampleInitializeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleInitialized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleInitialized_filter
    ): [ERC721OpenMintPMExampleInitialized!]!
    erc721OpenMintPMExampleRoleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleAdminChanged
    erc721OpenMintPMExampleRoleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleAdminChanged_filter
    ): [ERC721OpenMintPMExampleRoleAdminChanged!]!
    erc721OpenMintPMExampleRoleGranted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleGranted
    erc721OpenMintPMExampleRoleGranteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleGranted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleGranted_filter
    ): [ERC721OpenMintPMExampleRoleGranted!]!
    erc721OpenMintPMExampleRoleRevoked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleRevoked
    erc721OpenMintPMExampleRoleRevokeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleRevoked_filter
    ): [ERC721OpenMintPMExampleRoleRevoked!]!
    erc721OpenMintPMExampleUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleUpgraded
    erc721OpenMintPMExampleUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleUpgraded_filter
    ): [ERC721OpenMintPMExampleUpgraded!]!
    grantCategoryManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GrantCategoryManager
    grantCategoryManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GrantCategoryManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GrantCategoryManager_filter
    ): [GrantCategoryManager!]!
    grantMinter(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GrantMinter
    grantMinters(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GrantMinter_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GrantMinter_filter
    ): [GrantMinter!]!
    initialized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Initialized
    initializeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Initialized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Initialized_filter
    ): [Initialized!]!
    nft(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFT
    nfts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFT_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFT_filter
    ): [NFT!]!
    properties(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Property_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Property_filter
    ): [Property!]!
    property(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Property
    propertyManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PropertyManager
    propertyManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PropertyManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PropertyManager_filter
    ): [PropertyManager!]!
    removeCategoryManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RemoveCategoryManager
    removeCategoryManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RemoveCategoryManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RemoveCategoryManager_filter
    ): [RemoveCategoryManager!]!
    removeMinter(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RemoveMinter
    removeMinters(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RemoveMinter_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RemoveMinter_filter
    ): [RemoveMinter!]!
    roleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleAdminChanged
    roleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleAdminChanged_filter
    ): [RoleAdminChanged!]!
    roleGranted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleGranted
    roleGranteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleGranted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleGranted_filter
    ): [RoleGranted!]!
    roleRevoked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleRevoked
    roleRevokeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleRevoked_filter
    ): [RoleRevoked!]!
    setMetadataGenerator(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SetMetadataGenerator
    setMetadataGenerators(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SetMetadataGenerator_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SetMetadataGenerator_filter
    ): [SetMetadataGenerator!]!
    transfer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transfer
    transfers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transfer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Transfer_filter
    ): [Transfer!]!
    upgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Upgraded
    upgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Upgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Upgraded_filter
    ): [Upgraded!]!
}

type RemoveCategoryManager {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    category: Bytes!
    id: Bytes!
    manager: Bytes!
    transactionHash: Bytes!
}

type RemoveMinter {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    manager: Bytes!
    transactionHash: Bytes!
}

type RoleAdminChanged {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newAdminRole: Bytes!
    previousAdminRole: Bytes!
    role: Bytes!
    transactionHash: Bytes!
}

type RoleGranted {
    account: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    role: Bytes!
    sender: Bytes!
    transactionHash: Bytes!
}

type RoleRevoked {
    account: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    role: Bytes!
    sender: Bytes!
    transactionHash: Bytes!
}

type SetMetadataGenerator {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    generator: Bytes!
    id: Bytes!
    property: Bytes!
    transactionHash: Bytes!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    addCategories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AddCategory_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AddCategory_filter
    ): [AddCategory!]!
    addCategory(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddCategory
    addCategoryProperties(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AddCategoryProperty_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AddCategoryProperty_filter
    ): [AddCategoryProperty!]!
    addCategoryProperty(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddCategoryProperty
    adminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AdminChanged
    adminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AdminChanged_filter
    ): [AdminChanged!]!
    approval(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Approval
    approvalForAll(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ApprovalForAll
    approvalForAlls(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ApprovalForAll_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ApprovalForAll_filter
    ): [ApprovalForAll!]!
    approvals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Approval_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Approval_filter
    ): [Approval!]!
    beaconUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BeaconUpgraded
    beaconUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BeaconUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BeaconUpgraded_filter
    ): [BeaconUpgraded!]!
    categories(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Category_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Category_filter
    ): [Category!]!
    category(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Category
    erc721OpenMintPMExampleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleAdminChanged
    erc721OpenMintPMExampleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleAdminChanged_filter
    ): [ERC721OpenMintPMExampleAdminChanged!]!
    erc721OpenMintPMExampleBeaconUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleBeaconUpgraded
    erc721OpenMintPMExampleBeaconUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleBeaconUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleBeaconUpgraded_filter
    ): [ERC721OpenMintPMExampleBeaconUpgraded!]!
    erc721OpenMintPMExampleInitialized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleInitialized
    erc721OpenMintPMExampleInitializeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleInitialized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleInitialized_filter
    ): [ERC721OpenMintPMExampleInitialized!]!
    erc721OpenMintPMExampleRoleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleAdminChanged
    erc721OpenMintPMExampleRoleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleAdminChanged_filter
    ): [ERC721OpenMintPMExampleRoleAdminChanged!]!
    erc721OpenMintPMExampleRoleGranted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleGranted
    erc721OpenMintPMExampleRoleGranteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleGranted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleGranted_filter
    ): [ERC721OpenMintPMExampleRoleGranted!]!
    erc721OpenMintPMExampleRoleRevoked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleRoleRevoked
    erc721OpenMintPMExampleRoleRevokeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleRoleRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleRoleRevoked_filter
    ): [ERC721OpenMintPMExampleRoleRevoked!]!
    erc721OpenMintPMExampleUpgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ERC721OpenMintPMExampleUpgraded
    erc721OpenMintPMExampleUpgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ERC721OpenMintPMExampleUpgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ERC721OpenMintPMExampleUpgraded_filter
    ): [ERC721OpenMintPMExampleUpgraded!]!
    grantCategoryManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GrantCategoryManager
    grantCategoryManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GrantCategoryManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GrantCategoryManager_filter
    ): [GrantCategoryManager!]!
    grantMinter(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GrantMinter
    grantMinters(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GrantMinter_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GrantMinter_filter
    ): [GrantMinter!]!
    initialized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Initialized
    initializeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Initialized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Initialized_filter
    ): [Initialized!]!
    nft(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFT
    nfts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFT_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFT_filter
    ): [NFT!]!
    properties(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Property_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Property_filter
    ): [Property!]!
    property(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Property
    propertyManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PropertyManager
    propertyManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PropertyManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PropertyManager_filter
    ): [PropertyManager!]!
    removeCategoryManager(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RemoveCategoryManager
    removeCategoryManagers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RemoveCategoryManager_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RemoveCategoryManager_filter
    ): [RemoveCategoryManager!]!
    removeMinter(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RemoveMinter
    removeMinters(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RemoveMinter_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RemoveMinter_filter
    ): [RemoveMinter!]!
    roleAdminChanged(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleAdminChanged
    roleAdminChangeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleAdminChanged_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleAdminChanged_filter
    ): [RoleAdminChanged!]!
    roleGranted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleGranted
    roleGranteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleGranted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleGranted_filter
    ): [RoleGranted!]!
    roleRevoked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleRevoked
    roleRevokeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleRevoked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleRevoked_filter
    ): [RoleRevoked!]!
    setMetadataGenerator(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SetMetadataGenerator
    setMetadataGenerators(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SetMetadataGenerator_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SetMetadataGenerator_filter
    ): [SetMetadataGenerator!]!
    transfer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transfer
    transfers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transfer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Transfer_filter
    ): [Transfer!]!
    upgraded(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Upgraded
    upgradeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Upgraded_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Upgraded_filter
    ): [Upgraded!]!
}

type Transfer {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    from: Bytes!
    id: Bytes!
    manager: PropertyManager!
    to: Bytes!
    tokenId: BigInt!
    transactionHash: Bytes!
}

type Upgraded {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    implementation: Bytes!
    transactionHash: Bytes!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum AddCategoryProperty_orderBy {
    blockNumber
    blockTimestamp
    category
    id
    properties
    transactionHash
}

enum AddCategory_orderBy {
    allowSplit
    blockNumber
    blockTimestamp
    category
    id
    manager
    properties
    transactionHash
}

enum AdminChanged_orderBy {
    blockNumber
    blockTimestamp
    id
    newAdmin
    previousAdmin
    transactionHash
}

enum ApprovalForAll_orderBy {
    approved
    blockNumber
    blockTimestamp
    id
    manager
    operator
    owner
    transactionHash
}

enum Approval_orderBy {
    approved
    blockNumber
    blockTimestamp
    id
    manager
    owner
    tokenId
    transactionHash
}

enum BeaconUpgraded_orderBy {
    beacon
    blockNumber
    blockTimestamp
    id
    transactionHash
}

enum Category_orderBy {
    allowSplit
    category
    id
    manager
    properties
}

enum ERC721OpenMintPMExampleAdminChanged_orderBy {
    blockNumber
    blockTimestamp
    id
    newAdmin
    previousAdmin
    transactionHash
}

enum ERC721OpenMintPMExampleBeaconUpgraded_orderBy {
    beacon
    blockNumber
    blockTimestamp
    id
    transactionHash
}

enum ERC721OpenMintPMExampleInitialized_orderBy {
    blockNumber
    blockTimestamp
    id
    transactionHash
    version
}

enum ERC721OpenMintPMExampleRoleAdminChanged_orderBy {
    blockNumber
    blockTimestamp
    id
    newAdminRole
    previousAdminRole
    role
    transactionHash
}

enum ERC721OpenMintPMExampleRoleGranted_orderBy {
    account
    blockNumber
    blockTimestamp
    id
    role
    sender
    transactionHash
}

enum ERC721OpenMintPMExampleRoleRevoked_orderBy {
    account
    blockNumber
    blockTimestamp
    id
    role
    sender
    transactionHash
}

enum ERC721OpenMintPMExampleUpgraded_orderBy {
    blockNumber
    blockTimestamp
    id
    implementation
    transactionHash
}

enum GrantCategoryManager_orderBy {
    blockNumber
    blockTimestamp
    category
    id
    manager
    transactionHash
}

enum GrantMinter_orderBy {
    blockNumber
    blockTimestamp
    id
    manager
    transactionHash
}

enum Initialized_orderBy {
    blockNumber
    blockTimestamp
    id
    transactionHash
    version
}

enum NFT_orderBy {
    blockNumber
    blockTimestamp
    id
    manager
    owner
    tokenId
    transactionHash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum PropertyManager_orderBy {
    categories
    id
    manager
    minter
    name
    sender
}

enum Property_orderBy {
    blockNumber
    blockTimestamp
    category
    id
    transactionHash
    value
}

enum RemoveCategoryManager_orderBy {
    blockNumber
    blockTimestamp
    category
    id
    manager
    transactionHash
}

enum RemoveMinter_orderBy {
    blockNumber
    blockTimestamp
    id
    manager
    transactionHash
}

enum RoleAdminChanged_orderBy {
    blockNumber
    blockTimestamp
    id
    newAdminRole
    previousAdminRole
    role
    transactionHash
}

enum RoleGranted_orderBy {
    account
    blockNumber
    blockTimestamp
    id
    role
    sender
    transactionHash
}

enum RoleRevoked_orderBy {
    account
    blockNumber
    blockTimestamp
    id
    role
    sender
    transactionHash
}

enum SetMetadataGenerator_orderBy {
    blockNumber
    blockTimestamp
    generator
    id
    property
    transactionHash
}

enum Transfer_orderBy {
    blockNumber
    blockTimestamp
    from
    id
    manager
    to
    tokenId
    transactionHash
}

enum Upgraded_orderBy {
    blockNumber
    blockTimestamp
    id
    implementation
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input AddCategoryProperty_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: Bytes
    category_contains: Bytes
    category_in: [Bytes!]
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    properties: [Bytes!]
    properties_contains: [Bytes!]
    properties_contains_nocase: [Bytes!]
    properties_not: [Bytes!]
    properties_not_contains: [Bytes!]
    properties_not_contains_nocase: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input AddCategory_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    allowSplit: Boolean
    allowSplit_in: [Boolean!]
    allowSplit_not: Boolean
    allowSplit_not_in: [Boolean!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: Bytes
    category_contains: Bytes
    category_in: [Bytes!]
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    properties: [Bytes!]
    properties_contains: [Bytes!]
    properties_contains_nocase: [Bytes!]
    properties_not: [Bytes!]
    properties_not_contains: [Bytes!]
    properties_not_contains_nocase: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input AdminChanged_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newAdmin: Bytes
    newAdmin_contains: Bytes
    newAdmin_in: [Bytes!]
    newAdmin_not: Bytes
    newAdmin_not_contains: Bytes
    newAdmin_not_in: [Bytes!]
    previousAdmin: Bytes
    previousAdmin_contains: Bytes
    previousAdmin_in: [Bytes!]
    previousAdmin_not: Bytes
    previousAdmin_not_contains: Bytes
    previousAdmin_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ApprovalForAll_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    approved: Boolean
    approved_in: [Boolean!]
    approved_not: Boolean
    approved_not_in: [Boolean!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: String
    manager_: PropertyManager_filter
    manager_contains: String
    manager_contains_nocase: String
    manager_ends_with: String
    manager_ends_with_nocase: String
    manager_gt: String
    manager_gte: String
    manager_in: [String!]
    manager_lt: String
    manager_lte: String
    manager_not: String
    manager_not_contains: String
    manager_not_contains_nocase: String
    manager_not_ends_with: String
    manager_not_ends_with_nocase: String
    manager_not_in: [String!]
    manager_not_starts_with: String
    manager_not_starts_with_nocase: String
    manager_starts_with: String
    manager_starts_with_nocase: String
    operator: Bytes
    operator_contains: Bytes
    operator_in: [Bytes!]
    operator_not: Bytes
    operator_not_contains: Bytes
    operator_not_in: [Bytes!]
    owner: Bytes
    owner_contains: Bytes
    owner_in: [Bytes!]
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Approval_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    approved: Bytes
    approved_contains: Bytes
    approved_in: [Bytes!]
    approved_not: Bytes
    approved_not_contains: Bytes
    approved_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: String
    manager_: PropertyManager_filter
    manager_contains: String
    manager_contains_nocase: String
    manager_ends_with: String
    manager_ends_with_nocase: String
    manager_gt: String
    manager_gte: String
    manager_in: [String!]
    manager_lt: String
    manager_lte: String
    manager_not: String
    manager_not_contains: String
    manager_not_contains_nocase: String
    manager_not_ends_with: String
    manager_not_ends_with_nocase: String
    manager_not_in: [String!]
    manager_not_starts_with: String
    manager_not_starts_with_nocase: String
    manager_starts_with: String
    manager_starts_with_nocase: String
    owner: Bytes
    owner_contains: Bytes
    owner_in: [Bytes!]
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input BeaconUpgraded_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    beacon: Bytes
    beacon_contains: Bytes
    beacon_in: [Bytes!]
    beacon_not: Bytes
    beacon_not_contains: Bytes
    beacon_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input Category_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    allowSplit: Boolean
    allowSplit_in: [Boolean!]
    allowSplit_not: Boolean
    allowSplit_not_in: [Boolean!]
    category: Bytes
    category_contains: Bytes
    category_in: [Bytes!]
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: String
    manager_: PropertyManager_filter
    manager_contains: String
    manager_contains_nocase: String
    manager_ends_with: String
    manager_ends_with_nocase: String
    manager_gt: String
    manager_gte: String
    manager_in: [String!]
    manager_lt: String
    manager_lte: String
    manager_not: String
    manager_not_contains: String
    manager_not_contains_nocase: String
    manager_not_ends_with: String
    manager_not_ends_with_nocase: String
    manager_not_in: [String!]
    manager_not_starts_with: String
    manager_not_starts_with_nocase: String
    manager_starts_with: String
    manager_starts_with_nocase: String
    properties_: Property_filter
}

input ERC721OpenMintPMExampleAdminChanged_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newAdmin: Bytes
    newAdmin_contains: Bytes
    newAdmin_in: [Bytes!]
    newAdmin_not: Bytes
    newAdmin_not_contains: Bytes
    newAdmin_not_in: [Bytes!]
    previousAdmin: Bytes
    previousAdmin_contains: Bytes
    previousAdmin_in: [Bytes!]
    previousAdmin_not: Bytes
    previousAdmin_not_contains: Bytes
    previousAdmin_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ERC721OpenMintPMExampleBeaconUpgraded_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    beacon: Bytes
    beacon_contains: Bytes
    beacon_in: [Bytes!]
    beacon_not: Bytes
    beacon_not_contains: Bytes
    beacon_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ERC721OpenMintPMExampleInitialized_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    version: Int
    version_gt: Int
    version_gte: Int
    version_in: [Int!]
    version_lt: Int
    version_lte: Int
    version_not: Int
    version_not_in: [Int!]
}

input ERC721OpenMintPMExampleRoleAdminChanged_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newAdminRole: Bytes
    newAdminRole_contains: Bytes
    newAdminRole_in: [Bytes!]
    newAdminRole_not: Bytes
    newAdminRole_not_contains: Bytes
    newAdminRole_not_in: [Bytes!]
    previousAdminRole: Bytes
    previousAdminRole_contains: Bytes
    previousAdminRole_in: [Bytes!]
    previousAdminRole_not: Bytes
    previousAdminRole_not_contains: Bytes
    previousAdminRole_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ERC721OpenMintPMExampleRoleGranted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ERC721OpenMintPMExampleRoleRevoked_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ERC721OpenMintPMExampleUpgraded_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    implementation: Bytes
    implementation_contains: Bytes
    implementation_in: [Bytes!]
    implementation_not: Bytes
    implementation_not_contains: Bytes
    implementation_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input GrantCategoryManager_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: Bytes
    category_contains: Bytes
    category_in: [Bytes!]
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input GrantMinter_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Initialized_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    version: Int
    version_gt: Int
    version_gte: Int
    version_in: [Int!]
    version_lt: Int
    version_lte: Int
    version_not: Int
    version_not_in: [Int!]
}

input NFT_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    manager: String
    manager_: PropertyManager_filter
    manager_contains: String
    manager_contains_nocase: String
    manager_ends_with: String
    manager_ends_with_nocase: String
    manager_gt: String
    manager_gte: String
    manager_in: [String!]
    manager_lt: String
    manager_lte: String
    manager_not: String
    manager_not_contains: String
    manager_not_contains_nocase: String
    manager_not_ends_with: String
    manager_not_ends_with_nocase: String
    manager_not_in: [String!]
    manager_not_starts_with: String
    manager_not_starts_with_nocase: String
    manager_starts_with: String
    manager_starts_with_nocase: String
    owner: Bytes
    owner_contains: Bytes
    owner_in: [Bytes!]
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input PropertyManager_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    categories_: Category_filter
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    minter: Boolean
    minter_in: [Boolean!]
    minter_not: Boolean
    minter_not_in: [Boolean!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
}

input Property_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: String
    category_: Category_filter
    category_contains: String
    category_contains_nocase: String
    category_ends_with: String
    category_ends_with_nocase: String
    category_gt: String
    category_gte: String
    category_in: [String!]
    category_lt: String
    category_lte: String
    category_not: String
    category_not_contains: String
    category_not_contains_nocase: String
    category_not_ends_with: String
    category_not_ends_with_nocase: String
    category_not_in: [String!]
    category_not_starts_with: String
    category_not_starts_with_nocase: String
    category_starts_with: String
    category_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    value: Bytes
    value_contains: Bytes
    value_in: [Bytes!]
    value_not: Bytes
    value_not_contains: Bytes
    value_not_in: [Bytes!]
}

input RemoveCategoryManager_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    category: Bytes
    category_contains: Bytes
    category_in: [Bytes!]
    category_not: Bytes
    category_not_contains: Bytes
    category_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RemoveMinter_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: Bytes
    manager_contains: Bytes
    manager_in: [Bytes!]
    manager_not: Bytes
    manager_not_contains: Bytes
    manager_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleAdminChanged_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newAdminRole: Bytes
    newAdminRole_contains: Bytes
    newAdminRole_in: [Bytes!]
    newAdminRole_not: Bytes
    newAdminRole_not_contains: Bytes
    newAdminRole_not_in: [Bytes!]
    previousAdminRole: Bytes
    previousAdminRole_contains: Bytes
    previousAdminRole_in: [Bytes!]
    previousAdminRole_not: Bytes
    previousAdminRole_not_contains: Bytes
    previousAdminRole_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleGranted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleRevoked_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SetMetadataGenerator_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    generator: Bytes
    generator_contains: Bytes
    generator_in: [Bytes!]
    generator_not: Bytes
    generator_not_contains: Bytes
    generator_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    property: Bytes
    property_contains: Bytes
    property_in: [Bytes!]
    property_not: Bytes
    property_not_contains: Bytes
    property_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Transfer_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    from: Bytes
    from_contains: Bytes
    from_in: [Bytes!]
    from_not: Bytes
    from_not_contains: Bytes
    from_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    manager: String
    manager_: PropertyManager_filter
    manager_contains: String
    manager_contains_nocase: String
    manager_ends_with: String
    manager_ends_with_nocase: String
    manager_gt: String
    manager_gte: String
    manager_in: [String!]
    manager_lt: String
    manager_lte: String
    manager_not: String
    manager_not_contains: String
    manager_not_contains_nocase: String
    manager_not_ends_with: String
    manager_not_ends_with_nocase: String
    manager_not_in: [String!]
    manager_not_starts_with: String
    manager_not_starts_with_nocase: String
    manager_starts_with: String
    manager_starts_with_nocase: String
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Upgraded_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    implementation: Bytes
    implementation_contains: Bytes
    implementation_in: [Bytes!]
    implementation_not: Bytes
    implementation_not_contains: Bytes
    implementation_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}
